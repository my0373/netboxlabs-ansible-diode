#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright 2024-2026 NetBox Labs Inc
# Apache License 2.0 (see LICENSE)

"""Ansible module for replaying dry-run JSON files into Diode."""

from __future__ import absolute_import, division, print_function

__metaclass__ = type

DOCUMENTATION = r"""
---
module: diode_replay
short_description: Replay dry-run JSON files into a Diode instance
version_added: "1.0.0"
description:
  - Load entities from one or more JSON files previously generated by
    M(my0373.diode.diode_dry_run) and ingest them into a live Diode
    service.
  - This enables a review-then-apply workflow where entities are first
    written to JSON for inspection and then replayed when approved.
extends_documentation_fragment:
  - my0373.diode.common.DIODE_CONNECTION
options:
  files:
    description:
      - List of paths to dry-run JSON files to replay.
      - Each file must have been generated by M(my0373.diode.diode_dry_run)
        or the C(DiodeDryRunClient).
    type: list
    elements: path
    required: true
  chunk_size_mb:
    description:
      - Maximum size in megabytes for each gRPC message chunk.
    type: float
    default: 3.0
author:
  - Matt York (@my0373)
  - NetBox Labs
"""

EXAMPLES = r"""
- name: Replay a single dry-run file
  my0373.diode.diode_replay:
    target: "grpc://diode.example.com:8080/diode"
    app_name: "ansible-replay"
    app_version: "1.0.0"
    files:
      - "/tmp/diode-dryrun/my_import_1706123456789.json"
"""

RETURN = r"""
changed:
  description: Whether entities were ingested.
  type: bool
  returned: always
  sample: true
total_ingested:
  description: Total number of entities ingested across all files.
  type: int
  returned: success
  sample: 42
files_processed:
  description: Number of files successfully processed.
  type: int
  returned: success
  sample: 2
errors:
  description: List of error messages, if any.
  type: list
  elements: str
  returned: always
  sample: []
"""

import os

from ansible.module_utils.basic import AnsibleModule

from ansible_collections.my0373.diode.plugins.module_utils.arg_specs import (
    diode_connection_arg_spec,
)
from ansible_collections.my0373.diode.plugins.module_utils.client import (
    HAS_DIODE_SDK,
    SDK_IMPORT_ERROR,
    create_diode_client,
    ingest_with_chunking,
)

try:
    from netboxlabs.diode.sdk import load_dryrun_entities

    HAS_LOAD_DRYRUN = True
except ImportError:
    HAS_LOAD_DRYRUN = False


def main():
    """Main entry point for module execution."""
    arg_spec = {}
    arg_spec.update(diode_connection_arg_spec())
    arg_spec.update(
        dict(
            files=dict(type="list", elements="path", required=True),
            chunk_size_mb=dict(type="float", default=3.0),
        )
    )

    module = AnsibleModule(
        argument_spec=arg_spec,
        supports_check_mode=True,
    )

    if not HAS_DIODE_SDK or not HAS_LOAD_DRYRUN:
        module.fail_json(msg=SDK_IMPORT_ERROR)

    files = module.params["files"]

    for filepath in files:
        if not os.path.isfile(filepath):
            module.fail_json(msg="File not found: {0}".format(filepath))

    if module.check_mode:
        module.exit_json(
            changed=True,
            total_ingested=0,
            files_processed=len(files),
            errors=[],
        )

    try:
        client = create_diode_client(module.params)
    except Exception as exc:
        module.fail_json(msg="Failed to create Diode client: {0}".format(str(exc)))

    total_ingested = 0
    files_processed = 0
    all_errors = []

    try:
        with client:
            for filepath in files:
                try:
                    entities = list(load_dryrun_entities(filepath))
                except Exception as exc:
                    all_errors.append(
                        "Failed to load {0}: {1}".format(filepath, str(exc))
                    )
                    continue

                result = ingest_with_chunking(
                    client=client,
                    entities=entities,
                    chunk_size_mb=module.params.get("chunk_size_mb", 3.0),
                )
                total_ingested += result["ingested_count"]
                all_errors.extend(result["errors"])
                files_processed += 1
    except Exception as exc:
        module.fail_json(msg="Replay failed: {0}".format(str(exc)))

    module.exit_json(
        changed=total_ingested > 0,
        total_ingested=total_ingested,
        files_processed=files_processed,
        errors=all_errors,
    )


if __name__ == "__main__":
    main()
